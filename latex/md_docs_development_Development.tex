This document is primarily for developers only.

\subsection*{General principals}


\begin{DoxyEnumerate}
\item Name everything well.
\item Strike a balance between simplicity and not-\/repeating code.
\item Methods that return a boolean should be named as a question, and should not change state. e.\+g. 'is\+Ok\+To\+Arm()'
\item Methods that start with the word 'find' can return a null, methods that start with 'get' should not.
\item Methods should have verb or verb-\/phrase names, like {\ttfamily delete\+Page} or {\ttfamily save}. Variables should not, they generally should be nouns. Tell the system to 'do' something 'with' something. e.\+g. delete\+All\+Pages(page\+List).
\item Keep methods short -\/ it makes it easier to test.
\item Don't be afraid of moving code to a new file -\/ it helps to reduce test dependencies.
\item Avoid noise-\/words in variable names, like 'data' or 'info'. Think about what you're naming and name it well. Don't be afraid to rename anything.
\item Avoid comments that describe what the code is doing, the code should describe itself. Comments are useful however for big-\/picture purposes and to document content of variables.
\item If you need to document a variable do it at the declaration, don't copy the comment to the {\ttfamily extern} usage since it will lead to comment rot.
\item Seek advice from other developers -\/ know you can always learn more.
\item Be professional -\/ attempts at humor or slating existing code in the codebase itself is not helpful when you have to change/fix it.
\item Know that there's always more than one way to do something and that code is never final -\/ but it does have to work.
\end{DoxyEnumerate}

Before making any code contributions, take a note of the \href{https://github.com/multiwii/baseflight/wiki/CodingStyle}{\tt https\+://github.\+com/multiwii/baseflight/wiki/\+Coding\+Style}

It is also advised to read about clean code, here are some useful links\+:


\begin{DoxyItemize}
\item \href{http://cleancoders.com/}{\tt http\+://cleancoders.\+com/}
\item \href{http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29}{\tt http\+://en.\+wikipedia.\+org/wiki/\+S\+O\+L\+I\+D\+\_\+\%28object-\/oriented\+\_\+design\%29}
\item \href{http://en.wikipedia.org/wiki/Code_smell}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Code\+\_\+smell}
\item \href{http://en.wikipedia.org/wiki/Code_refactoring}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Code\+\_\+refactoring}
\item \href{http://www.amazon.co.uk/Working-Effectively-Legacy-Robert-Martin/dp/0131177052}{\tt http\+://www.\+amazon.\+co.\+uk/\+Working-\/\+Effectively-\/\+Legacy-\/\+Robert-\/\+Martin/dp/0131177052}
\end{DoxyItemize}

\subsection*{Unit testing}

Ideally, there should be tests for any new code. However, since this is a legacy codebase which was not designed to be tested this might be a bit difficult.

If you want to make changes and want to make sure it's tested then focus on the minimal set of changes required to add a test.

Tests currently live in the {\ttfamily test} folder and they use the google test framework. The tests are compiled and run natively on your development machine and not on the target platform. This allows you to develop tests and code and actually execute it to make sure it works without needing a development board or simulator.

This project could really do with some functional tests which test the behaviour of the application.

All pull requests to add/improve the testability of the code or testing methods are highly sought!

Note\+: Tests are written in C++ and linked with with firmware's C code. All code is also instrumented using gcov to make test coverage analysis possible.

\subsubsection*{Running the tests.}

The tests and test build system is very simple and based off the googletest example files, it will be improved in due course. From the root folder of the project simply do\+:

``` make test ```

You can also do\+:

``` make junittest ```

This will build a set of executable files in the {\ttfamily obj/test} folder, one for each {\ttfamily $\ast$\+\_\+unittest.cc} file.

After they have been executed by the make invocation, you can still run them on the command line to execute the tests and to see the test report. Test reports will also be produced in form of junit X\+M\+L files, if tests are built and run with the \char`\"{}junittest\char`\"{} goal. Junit report files are saved in obj/test directory and has the following naming pattern test\+\_\+name\+\_\+results.\+xml, for example\+: obj/test/battery\+\_\+unittest\+\_\+results.\+xml

You can also step-\/debug the tests in eclipse and you can use the Google\+Test test runner to make building and re-\/running the tests simple.

The tests are currently always compiled with debugging information enabled, there may be additional warnings, if you see any warnings please attempt to fix them and submit pull requests with the fixes.

Tests are verified and working with G\+C\+C 4.\+9.\+2.

\subsection*{Test coverage analysis}

There are a number of possibilities to analyse test coverage and produce various reports. There are guides available from many sources, a good overview and link collection to more info can be found on Wikipedia\+:

\href{https://en.wikipedia.org/wiki/Gcov}{\tt https\+://en.\+wikipedia.\+org/wiki/\+Gcov}

A simple report for a single test can for example be made using this command\+:

``` gcov -\/s src/main/sensors -\/o obj/test/ \hyperlink{battery__unittest_8cc}{battery\+\_\+unittest.\+cc} ```

To produce an coverage report in xml format usable by the Cobertura plugin in Jenkins requires installation of a Python script called \char`\"{}gcovr\char`\"{} from github\+:

\href{https://github.com/gcovr/gcovr/tree/dev}{\tt https\+://github.\+com/gcovr/gcovr/tree/dev}

Example usage in Jenkins\+:

``` /gcovr-\/install-\/path/gcovr/scripts/gcovr obj/test --root=src/main -\/x $>$ coverage.\+xml ```

There are many other ways to prodice test coverage reports in other formats, like html etc etc.

\subsection*{Using git and github}

Ensure you understand the github workflow\+: \href{https://guides.github.com/introduction/flow/index.html}{\tt https\+://guides.\+github.\+com/introduction/flow/index.\+html}

Please keep pull requests focused on one thing only, since this makes it easier to merge and test in a timely manner.

If you need help with pull requests there are guides on github here\+:

\href{https://help.github.com/articles/creating-a-pull-request/}{\tt https\+://help.\+github.\+com/articles/creating-\/a-\/pull-\/request/}

The main flow for a contributing is as follows\+:


\begin{DoxyEnumerate}
\item Login to github, go to the cleanflight repository and press {\ttfamily fork}.
\item Then using the command line/terminal on your computer\+: {\ttfamily git clone $<$url to Y\+O\+U\+R fork$>$}
\item {\ttfamily cd cleanflight}
\item {\ttfamily git checkout master}
\item {\ttfamily git checkout -\/b my-\/new-\/code}
\item Make changes
\item {\ttfamily git add $<$files that have changed$>$}
\item {\ttfamily git commit}
\item {\ttfamily git push origin my-\/new-\/code}
\item Create pull request using github U\+I to merge your changes from your new branch into {\ttfamily cleanflight/master}
\item Repeat from step 4 for new other changes.
\end{DoxyEnumerate}

The primary thing to remember is that separate pull requests should be created for separate branches. Never create a pull request from your {\ttfamily master} branch.

Later, you can get the changes from the cleanflight repo into your {\ttfamily master} branch by adding cleanflight as a git remote and merging from it as follows\+:


\begin{DoxyEnumerate}
\item {\ttfamily git remote add cleanflight \href{https://github.com/cleanflight/cleanflight.git}{\tt https\+://github.\+com/cleanflight/cleanflight.\+git}}
\item {\ttfamily git checkout master}
\item {\ttfamily git fetch cleanflight}
\item {\ttfamily git merge cleanflight/master}
\item {\ttfamily git push origin master} is an optional step that will update your fork on github
\end{DoxyEnumerate}

You can also perform the git commands using the git client inside Eclipse. Refer to the Eclipse git manual. 
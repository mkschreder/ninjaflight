\hypertarget{group__RX}{\section{Receiver}
\label{group__RX}\index{Receiver@{Receiver}}
}
\subsubsection*{R\+C Interface (Radio Control) }

R\+C is a higher level interface to the low level R\+X functions. While R\+X is able to provide support for reading various receivers, R\+C set of functions allows you to check if certain stick combinations are active and also supports configurable functions that are triggered when a certain channel is in a certain range. To the application R\+C module provides an interface similar to that of a keyboard. It allows checking if a certain combination is active using rc\+\_\+key\+\_\+pressed() and it also supports callback listener (struct \hyperlink{structrc__event__listener}{rc\+\_\+event\+\_\+listener}) through which it can notify the application when a certain key transitions from one state to another.

\subsubsection*{R\+X (Lower level receiver) }

R\+X module is responsible for interfacing with various types of receivers. It does so by using system calls (struct \hyperlink{structsystem__calls}{system\+\_\+calls}) and supports interpreting pwm/ppm as well as serial receivers. The main responsibility of this module is to provide uniform access to receivers which usually involves remapping channels to a layout that is standard for the rest of Ninjaflight. This module also provides basic failsafe functionality by allowing user to configure how each channel responds to signal loss (it is possible to set a static value, keep previously received value or reset the channel to default value).

This is a summary of automatic tests that are done against the receiver module to guarantee that the module behaves according to the requirements set forth below.

\subsubsection*{Receiver Unit Tests }

This is a summary of automatic tests that are done against the receiver module to guarantee that the module behaves according to the requirements set forth below.


\begin{DoxyItemize}
\item R\+X should output data on 16 channels. If hardware supports less then rx should output failsafe values on the remaining channels. If supplied channel is out of range then rx should output {\itshape midrc}.
\item On startup all receiver channels should return failsafe values. As new channels are connected rx will return the received values. However as any of the channels lose signal rx should hold the value for a timeout and then mark the rx as not heathy and return failsafe for that single channel. As the channel is connected again, rx should become heathy. R\+X should report that it has signal until all channels are lost.
\item Upon signal loss (all channels first valid then invalid) all channels should be outputting failsafe values.
\item Each channel shall have configurable failsafe that can output one of three alternatives\+: 1) auto\+: all channels are set to midrc except throttle. 2) hold\+: holds old channel information. 3) set\+: failsafe returnes a user configurable value. For safety reasons, non-\/aux channels should only support A\+U\+T\+O mode.
\item Receiver shall support channel remapping using a string that specifies ordering of the channels. Incoming signal shall be mapped from supplied configuration into standard \char`\"{}\+A\+E\+R\+T12345678abcdefgh\char`\"{} channel ordering.
\item R\+X outputs shall be represented by microsecond interval in range of rx\+\_\+min\+\_\+usec$\ast$ to {\itshape rx\+\_\+max\+\_\+usec}. If any inputs are outside of this range then they should be properly constrianed. 
\end{DoxyItemize}
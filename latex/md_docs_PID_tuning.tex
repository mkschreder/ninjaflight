Every aspect of flight dynamics is controlled by the selected \char`\"{}\+P\+I\+D controller\char`\"{}. This is an algorithm which is responsible for reacting to your stick inputs and keeping the craft stable in the air by using the gyroscopes and/or accelerometers (depending on your flight mode).

The \char`\"{}\+P\+I\+Ds\char`\"{} are a set of tuning parameters which control the operation of the P\+I\+D controller. The optimal P\+I\+D settings are different on every craft, so if you can't find someone with your exact setup who will share their settings with you, some trial and error is required to find the best performing P\+I\+D settings.

A video on how to recognise and correct different flight problems caused by P\+I\+D settings is available here\+:

\href{https://www.youtube.com/watch?v=YNzqTGEl2xQ}{\tt https\+://www.\+youtube.\+com/watch?v=\+Y\+Nzq\+T\+G\+El2x\+Q}

Basically, the goal of the P\+I\+D controller is to bring the craft's rotation rate in all three axes to the rate that you're commanding with your sticks. An error is computed which is the difference between your target rotation rate and the actual one measured by the gyroscopes, and the controller tries to bring this error to zero.

\subsection*{P\+I\+Ds}

{\bfseries The P term} controls the strength of the correction that is applied to bring the craft toward the target angle or rotation rate. If the P term is too low, the craft will be difficult to control as it won't respond quickly enough to keep itself stable. If it is set too high, the craft will rapidly oscillate/shake as it continually overshoots its target.

{\bfseries The I term} corrects small, long term errors. If it is set too low, the craft's attitude will slowly drift. If it is set too high, the craft will oscillate (but with slower oscillations than with P being set too high).

{\bfseries The D term} attempts to increase system stability by monitoring the rate of change in the error. If the error is rapidly converging to zero, the D term causes the strength of the correction to be backed off in order to avoid overshooting the target.

\subsection*{T\+P\+A and T\+P\+A Breakpoint}

{\itshape T\+P\+A} stands for Throttle P\+I\+D Attenuation and according to \href{http://blog.alexyorke.net/what-is-tpa/}{\tt Alex\+York.\+net}\+:

\begin{quote}
\char`\"{}\+T\+P\+A basically allows an aggressively tuned multi-\/rotor (one that feels very locked in) to reduce its P\+I\+D gains when throttle is applied beyond the T\+P\+A threshold/breakpoint in order to eliminate fast oscillations..\char`\"{} \end{quote}


Note that T\+P\+A is set via C\+L\+I or on the P\+I\+D T\+U\+N\+I\+N\+G tab of the G\+U\+I. {\ttfamily tpa\+\_\+breakpoint} is set via C\+L\+I

Also note that T\+P\+A and {\ttfamily tpa\+\_\+breakpoint} may not be used with certain P\+I\+D controllers. Check the description on the individual controller.

T\+P\+A applies a P\+I\+D value reduction in relation to full throttle. It is used to apply dampening of P\+I\+D values as full throttle is reached.

{\bfseries T\+P\+A} = \% of dampening that will occur at full throttle.

{\bfseries tpa\+\_\+breakpoint} = the point in the throttle curve at which T\+P\+A will begin to be applied.

An Example\+: With T\+P\+A = 50 (or .5 in the G\+U\+I) and {\ttfamily tpa\+\_\+breakpoint} = 1500 (assumed throttle range 1000 -\/ 2000)


\begin{DoxyItemize}
\item At 1500 on the throttle channel, the P\+I\+Ds will begin to be dampened.
\item At 3/4 throttle (1750), P\+I\+Ds are reduced by approximately 25\% (half way between 1500 and 2000 the dampening will be 50\% of the total T\+P\+A value of 50\% in this example)
\item At full throttle (2000) the full amount of dampening set in T\+P\+A is applied. (50\% reduction in this example)
\item T\+P\+A can lead into increase of rotation rate when more throttle applied. You can get faster flips and rolls when more throttle applied due to coupling of P\+I\+D's and rates. Only the P\+I\+D controllers M\+W\+R\+E\+W\+R\+I\+T\+E and L\+U\+X are using a linear T\+P\+A implementation, where no rotation rates are affected when T\+P\+A is being used.
\end{DoxyItemize}



{\bfseries How and Why to use this?}

If you are getting oscillations starting at say 3/4 throttle, set {\ttfamily tpa\+\_\+breakpoint} = 1750 or lower (remember, this is assuming your throttle range is 1000-\/2000), and then slowly increase T\+P\+A until your oscillations are gone. Usually, you will want {\ttfamily tpa\+\_\+breakpoint} to start a little sooner than when your oscillations start so you'll want to experiment with the values to reduce/remove the oscillations.

\subsection*{P\+I\+D controllers}

Cleanflight has 3 built-\/in P\+I\+D controllers which each have a different flight behavior. Each controller requires different P\+I\+D settings for best performance, so if you tune your craft using one P\+I\+D controller, those settings will likely not work well on any of the other controllers. In Cleanflight v1.\+13.\+0 the M\+W\+R\+E\+W\+R\+I\+T\+E and L\+U\+X P\+I\+D controllers were equalised so that the same P\+I\+D settings can be used with those two P\+I\+D controllers (subject to a small margin of error).

You can change between P\+I\+D controllers by running {\ttfamily set pid\+\_\+controller=x} on the C\+L\+I tab of the Cleanflight Configurator, where {\ttfamily x} is the controller you want to use. Please read these notes first before trying one out.

Note that older Cleanflight versions had 6 pid controllers, experimental and old ones were removed in Cleanflight version 1.\+11.\+0 (A\+P\+I version 1.\+14.\+0).

\subsubsection*{P\+I\+D controller \char`\"{}\+M\+W23\char`\"{}}

This P\+I\+D Controller is a direct port of the P\+I\+D controller from Multi\+Wii 2.\+3 and later.

The algorithm handles roll and pitch differently to yaw. Users with problems on yaw authority should try this one.

In {\itshape Horizon} and {\itshape Angle} modes, this controller uses both the L\+E\+V\+E\+L \char`\"{}\+P\char`\"{} and \char`\"{}\+I\char`\"{} settings in order to tune the auto-\/leveling corrections in a similar way to the way that P and I settings are applied to roll and yaw axes in the {\itshape Acro} flight modes. The L\+E\+V\+E\+L \char`\"{}\+D\char`\"{} term is used as a limiter to constrain the maximum correction applied by the L\+E\+V\+E\+L \char`\"{}\+P\char`\"{} term.

Cleanflight 1.\+12.\+0 changed the default value for {\ttfamily P\+\_\+\+Level} from 90 to 20 because M\+W\+R\+E\+W\+R\+I\+T\+E became the default P\+I\+D controller. If you use M\+W23 then try setting this to 90 before flying.

\subsubsection*{P\+I\+D controller \char`\"{}\+M\+W\+R\+E\+W\+R\+I\+T\+E\char`\"{}}

This is the default P\+I\+D controller for Cleanflight v1.\+12.\+0 and later versions.

This is a newer P\+I\+D controller that is derived from the one in Multi\+Wii 2.\+3 and later. It works better from all accounts, and fixes some inherent problems in the way the old one worked. From reports, tuning is apparently easier, and it tolerates a wider range of P\+I\+D values well.

In {\itshape Angle} mode, this controller uses the L\+E\+V\+E\+L \char`\"{}\+P\char`\"{} P\+I\+D setting to decide how strong the auto-\/level correction should be.

Cleanflight 1.\+12.\+0 changed the default value for {\ttfamily p\+\_\+level} to 20. This is the recommended value for the M\+W\+R\+E\+W\+R\+I\+T\+E P\+I\+D controller which provides a stable flight in {\itshape Angle} mode. The old default value was 90 which provided a very unstable flight for some users with this pid controller.

In {\itshape Horizon} mode, this controller uses the L\+E\+V\+E\+L \char`\"{}\+I\char`\"{} P\+I\+D setting to decide how much auto-\/level correction should be applied. Level \char`\"{}\+I\char`\"{} term\+: Strength of horizon auto-\/level. Value of 0.\+030 in the configurator equals to 3.\+0 for {\ttfamily i\+\_\+level}. Level \char`\"{}\+D\char`\"{} term\+: Strength of horizon transition. 0 is more stick travel on level and 255 is more rate mode what means very narrow angle of leveling.

\subsubsection*{P\+I\+D controller \char`\"{}\+L\+U\+X\char`\"{}}

This is a new floating point based P\+I\+D controller. M\+W23 and M\+W\+R\+E\+W\+R\+I\+T\+E use integer arithmetic, which was faster in the days of the slower 8-\/bit Multi\+Wii controllers, but is less precise.

In Cleanflight v1.\+13 the L\+U\+X P\+I\+D controller was changed so that it uses the same P\+I\+D settings as M\+W\+R\+E\+W\+R\+I\+T\+E.

This controller has code that attempts to compensate for variations in the looptime, which should mean that the P\+I\+Ds don't have to be retuned when the looptime setting changes.

There were initially some problems with {\itshape Horizon} mode, and sluggishness in {\itshape Acro} mode, that were recently fixed by \href{https://github.com/nebbian}{\tt nebbian} in v1.\+6.\+0.

It is the first P\+I\+D Controller designed for 32-\/bit processors and not derived from Multi\+Wii.

The strength of the auto-\/leveling correction applied during {\itshape Angle} mode is controlled by the L\+E\+V\+E\+L \char`\"{}\+P\char`\"{} P\+I\+D term which is labeled \char`\"{}\+L\+E\+V\+E\+L Proportional\char`\"{} in the G\+U\+I (prior to version v1.\+13.\+0 the parameter {\ttfamily level\+\_\+angle} was used). This can be used to tune the auto-\/leveling strength in {\itshape Angle} mode compared to {\itshape Horizon} mode. The default is 5.\+0.

The strength of the auto-\/leveling correction applied during {\itshape Horizon} mode is set by the L\+E\+V\+E\+L \char`\"{}\+I\char`\"{} P\+I\+D term which is labeled \char`\"{}\+L\+E\+V\+E\+L Integral\char`\"{} in the G\+U\+I (prior to version v1.\+13.\+0 the parameter {\ttfamily level\+\_\+horizon} was used). The default is 3.\+0, which makes the {\itshape Horizon} mode apply weaker self-\/leveling than the {\itshape Angle} mode. Note\+: There is currently a bug in the Configurator which shows this parameter divided by 100 (so it shows as 0.\+03 rather than 3.\+0).

The transition between self-\/leveling and acro behavior in {\itshape Horizon} mode is controlled by the L\+E\+V\+E\+L \char`\"{}\+D\char`\"{} term which is labeled \char`\"{}\+L\+E\+V\+E\+L Derivative\char`\"{} in the G\+U\+I (prior to version of v1.\+13.\+0 the parameter {\ttfamily sensitivity\+\_\+horizon} parameter was used) . This sets the percentage of your stick travel that should have self-\/leveling applied to it, so smaller values cause more of the stick area to fly using only the gyros. The default is 75\%

For example, at a setting of \char`\"{}100\char`\"{} for sensitivity horizon, 100\% self-\/leveling strength will be applied at center stick, 50\% self-\/leveling will be applied at 50\% stick, and no self-\/leveling will be applied at 100\% stick. If sensitivity is decreased to 75, 100\% self-\/leveling will be applied at center stick, 50\% will be applied at 63\% stick, and no self-\/leveling will be applied at 75\% stick and onwards.

\subsection*{R\+C rate, Pitch and Roll Rates (P/\+R rate before they were separated), and Yaw rate}

\subsubsection*{R\+C Rate}

An overall multiplier on the R\+C stick inputs for pitch, roll, and yaw.

On P\+I\+D Controller M\+W23 can be used to set the \char`\"{}feel\char`\"{} around center stick for small control movements. (R\+C Expo also affects this). For P\+I\+D Controllers M\+W\+R\+E\+W\+R\+I\+T\+E and L\+U\+X, this basically sets the baseline stick sensitivity.

\subsubsection*{Pitch and Roll rates}

In P\+I\+D Controller M\+W23 the affect of the P\+I\+D error terms for P and D are gradually lessened as the control sticks are moved away from center, ie 0.\+3 rate gives a 30\% reduction of those terms at full throw, effectively making the stabilizing effect of the P\+I\+D controller less at stick 90. This results in faster rotation rates. So for these controllers, you can set center stick sensitivity to control movement with R\+C rate above, and yet have much faster rotation rates at stick extremes.

For P\+I\+D Controllers M\+W\+R\+E\+W\+R\+I\+T\+E and L\+U\+X, this is an multiplier on overall stick sensitivity, like R\+C rate, but for roll and pitch independently. Stablility (to outside factors like turbulence) is not reduced at stick extremes. A zero value is no increase in stick sensitivity over that set by R\+C rate above. Higher values increases stick sensitivity across the entire stick movement range.

\subsubsection*{Yaw Rate}

In P\+I\+D Controllers M\+W\+R\+E\+W\+R\+I\+T\+E and L\+U\+X, it acts as a stick sensitivity multiplier, as explained above.

\subsubsection*{Filters}

{\ttfamily gyro\+\_\+lpf} sets the hardware gyro low pass filter value. If 0 or 256 the gyro uses the least hardware filtering available (256\+Hz) and the internal sampling rate is the fastest possible (8k\+Hz) with the least possible delay. The lower the number the stronger the filtering. Stronger filtering reduces noise in the gyro signal before that data gets into the P\+I\+D calculations. Stronger filtering adds delays that can be associated with wobble and reduced responsiveness. Filtering is needed because motor/frame noise can cause overheating of motors especially when amplified by Dterm in quads with low mass and fast braking E\+S\+Cs. If 188 or lower are chosen, the gyro sampling is internally at 1k\+Hz and delays are greater. Faster sampling is good because things are slightly more responsive but can cause aliasing noise. Setting to 188 allows syncing of the F\+C to the gyro at 1k\+Hz (if {\ttfamily gyro\+\_\+sync} is enabled and available in the code) which reduces aliasing a lot.

{\ttfamily gyro\+\_\+cut\+\_\+hz} is an I\+I\+R (Infinite Impulse Response) software low-\/pass filter that can be configured to any desired frequency. If set to a value above zero it is active. It works after the hardware filter on the gyro (in the F\+C code) and further reduces noise. The two filters in series have twice the cut rate of one alone. There's not a lot of sense running {\ttfamily gyro\+\_\+cut\+\_\+hz} at a value above {\ttfamily gyro\+\_\+lpf}. If used, it is typically set about half the hardware filter rate to enhance the cut of higher frequencies before the P\+I\+D calculations. Frequencies above 100\+Hz are of no interest to us from a flight control perspective -\/ they can and should be removed from the signal before it gets to the P\+I\+D calculation stage.

{\ttfamily pterm\+\_\+cut\+\_\+hz} is an I\+I\+R software low-\/pass filter that can be configured to any desired frequency. If enabled, it works after both the gyro\+\_\+cut filters. It specifically filters only the P term data. Lower values can therefore specifically help remove noise in the P term part of the P\+I\+D calculation. Blackbox recording is needed to determine what value works best on this filter. It is only really needed if you have P term noise despite the gyro filters, but typically it is needed with the commonly used relatively high gyro filter values.

{\ttfamily dterm\+\_\+cut\+\_\+hz} is an I\+I\+R software low-\/pass filter that can be configured to any desired frequency. It works after the gyro\+\_\+cut filters and specifically filters only the D term data. D term data is frequency dependent, the higher the frequency, the greater the computed D term value. This filter is required if despite the gyro filtering there remains excessive D term noise. Typically it needs to be set quite low because D term noise is a major problem with typical I\+I\+R filters. If set too low the phase shift in D term reduces the effectiveness of D term in controlling stop wobble, so this value needs some care when varying it. Again blackbox recording is needed to properly optimise the value for this filter. 